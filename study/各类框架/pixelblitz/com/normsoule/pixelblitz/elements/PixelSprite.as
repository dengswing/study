package com.normsoule.pixelblitz.elements{	import com.normsoule.pixelblitz.PixelBlitz;	import com.normsoule.pixelblitz.layers.RenderLayer;		import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.getQualifiedClassName;	/**	 * The PixelSprite class is the base class for all classes that	 *  can be added to a render layer and be rendered.	 * <p>	 * The PixelSprite class is very similar to the Sprite class but, in bitmap form.	 * Rotation, alpha, and scale are currently not supported.	 * </p>	 */	public dynamic class PixelSprite extends EventDispatcher	{		/**		 * @private		 */		protected const ZERO_POINT:Point = new Point();				/**		 * @private		 */		protected var _layer:RenderLayer;		/**		 * @private		 */		protected var collisionRect:Rectangle = new Rectangle();				/**		 * The horizontal position in pixels of the PixelSprite instance.		 */		public var x:Number 	= 0;		/**		 * The vertical position in pixels of the PixelSprite instance.		 */		public var y:Number 	= 0;		/**		 * The width in pixels of the PixelSprite instance.		 */		public var width:int 	= 0;		/**		 * The height in pixels of the PixelSprite instance.		 */		public var height:int 	= 0;		/**		 * The BitmapData object that will be rendered to the RenderLayer this object has been added to.		 */		public var bitmapData:BitmapData;		/**		 * The BitmapData object rect property.		 */		public var rect:Rectangle;				/**		 * Creates a PixelSprite instance.		 * <p>		 * Parses the supplied DisplayObject and converts the first frame of animation to a virtual frame.		 * The DisplayObject is drawn to a bitmapData object with the width and height of the 		 * DisplayObject defining the width and height of the BitmapData object.		 * </p>		 * @param displayObject The DisplayObject instance to convert into a PixelSprite object.		 */		public function PixelSprite( displayObject:DisplayObject )		{  			parseClip( displayObject );			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;		}				/**		 * @private		 * Parses the supplied DisplayObject and converts each frame of animation to a virtual frame.		 * @param displayObject The displayObject to convert.		 */		protected function parseClip( displayObject:DisplayObject ):void		{			var id:String = getQualifiedClassName( displayObject ) + "_" + 1;							// check if it is already in the collection			if ( PixelBlitz.bmdCollection.search( id ) )			{				bitmapData = PixelBlitz.bmdCollection.collection[ id ];			}			else			{				// create a new bitmapData object to draw on				var bmd:BitmapData = new BitmapData( displayObject.width, displayObject.height, true, 0x0 );				bmd.draw( displayObject );										// add the bitmapData to the collection				bitmapData = PixelBlitz.bmdCollection.addBitmapData( id, bmd );			}		}				/**		 * @private		 */		public function set layer( value:RenderLayer ):void		{			_layer = value;		}				/**		 * The depth or z-order of the PixelSprite instance.		 */		public function get depth():int		{			return _layer.getDepth( this );			}				/**		 * Performs a pixel-level collision check against the supplied PixelSprite object.		 * <p> 		 * This is a shape based collision test versus the standard DisplayObject bounding box <code>hitTestObject</code>.		 * The collision check compares the alpha value of each pixel. 		 * </p>		 * @param object The PixelSprite instance to test against.		 * @return Returns a boolean value indicating if a collision occured.		 * @example 		 * <code>		 * if ( obj1.getCollision( obj2 ) )		 * {		 * 		trace("collision occured");		 * }		 * </code>		 */		public function getCollision( object:PixelSprite ):Boolean		{			if ( bitmapData.hitTest( new Point(x, y), 1, object.bitmapData, new Point( object.x, object.y), 1 ) )			{				return true;			}			return false;		}				/**		 * Checks if the supplied point is inside of the PixelSprite object.		 * <p>		 * This method is useful for mouse detection where the point is the mouse x and y properties.		 * </p>		 * @param point The Point to test against.		 * @return A boolean value indicating if a collision occured.		 */		public function getCollisionPoint( point:Point ):Boolean		{			collisionRect.x = (x + PixelBlitz.camera2D.basePoint.x) * _layer.parrallax;			collisionRect.y = (y + PixelBlitz.camera2D.basePoint.y) * _layer.parrallax;			collisionRect.width = width;			collisionRect.height = height;			if ( collisionRect.containsPoint( point ) )			{				return true;			}			return false;		}				/**		 * Removes the PixelSprite from the RenderLayer it is registered to.		 * The dispose method also clears the internal data making it available for Garbage Collection.		 * All external refferences should be set to null as well to ensure it will be available for Garbage Collection.		 */		public function dispose():void		{			bitmapData = null;			_layer.removeItem( this );		}				/**		 * @private		 */		public function update():void 		{			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;		}		}}