package com.normsoule.pixelblitz.elements{		import com.normsoule.pixelblitz.PixelBlitz;		import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.utils.getQualifiedClassName;	/**	 * The PixelClip class adds a virtual timeline to the inherited PixelSprite class.	 * <p>	 * This class recreates the majority of the MovieClip methods.	 * Rotation, alpha, and scale are currently not supported.	 * </p>	 */	public dynamic class PixelClip extends PixelSprite	{			/**		 * @private		 */		protected var _frame:int;		/**		 * @private		 */		protected var animation:Array = [];		/**		 * @private		 */		protected var isPlaying:Boolean = true;				/**		 * Creates a PixelClip object.		 * <p>		 * Parses the supplied DisplayObject and converts the all frames of animation to virtual frames.		 * The DisplayObject is drawn to a bitmapData object with the width and height of the 		 * DisplayObject defining the width and height of the BitmapData object.		 * </p>		 * @param displayObject The DisplayObject instance to convert into a PixelClip object.		 */		public function PixelClip( displayObject:DisplayObject )		{  			super( displayObject );		}				/**		 * @private		 * Parses the supplied DisplayObject and converts each frame of animation to a virtual frame.		 * @param displayObject The displayObject to convert.		 */		protected override function parseClip( displayObject:DisplayObject ):void		{			if( displayObject is MovieClip )			{				for ( var i:int = 1; i <= MovieClip( displayObject ).totalFrames; i++ )				{					var id:String = getQualifiedClassName( displayObject ) + "_" + i;										// check if it is already in the collection					if ( PixelBlitz.bmdCollection.search( id ) )					{						animation.push( PixelBlitz.bmdCollection.collection[ id ] );					}					else					{						// advance to the frame to draw						MovieClip( displayObject ).gotoAndStop( i );											// create a new bitmapData object to draw on						var bmd:BitmapData = new BitmapData( displayObject.width, displayObject.height, true, 0x0 );						bmd.draw( displayObject );												// add the bitmapData to the collection						animation.push( PixelBlitz.bmdCollection.addBitmapData( id, bmd ) );					}				}			}			else 			{				id = getQualifiedClassName( displayObject ) + "_" + 1;								// check if it is already in the collection				if ( PixelBlitz.bmdCollection.search( id ) )				{					animation.push( PixelBlitz.bmdCollection.collection[ id ] );				}				else				{					// create a new bitmapData object to draw on					bmd = new BitmapData( displayObject.width, displayObject.height, true, 0x0 );					bmd.draw( displayObject );											// add the bitmapData to the collection					animation.push( PixelBlitz.bmdCollection.addBitmapData( id, bmd ) );				}			}			// init bitmapData			bitmapData = animation[_frame];		}				/**		 * The frame that the playhead is on.		 */		public function get currentFrame():int		{			return _frame;		}				/**		 * The total number of frames in the animation.		 */		public function get totalFrames():int		{			return animation.length;		}				/**		 * Moves the playhead to the next frame and stops.		 */		public function nextFrame():void		{			_frame = Math.min( _frame + 1, totalFrames - 1 );			isPlaying = false;		}				/**		 * Moves the playhead to the previous frame and stops.		 */		public function prevFrame():void		{			_frame = Math.max( _frame - 1, 0 );			isPlaying = false;		}				/**		 * Makes the playhead continue to advance, looping back to the first frame if the total number of frames is reached.		 */		public function play():void		{			isPlaying = true;		}				/**		 * Stops the playhead from advancing.		 */		public function stop():void		{			isPlaying = false;		}				/**		 * Moves the playhead to the supplied frame and continues playing.		 * 		 * @param frame The frame to advance to.		 */		public function gotoAndPlay( frame:int ):void		{			if ( frame < 0 ) 			{				_frame = 0; 			}			else if ( frame > totalFrames - 1 )			{				_frame = totalFrames - 1;			}			else			{				_frame = frame;			}			isPlaying = true;		}				/**		 * Moves the playhead to the supplied frame and stops playing.		 * 		 * @param frame The frame to move the playhead to.		 */		public function gotoAndStop( frame:int ):void		{			if ( frame < 0 ) 			{				_frame = 0; 			}			else if ( frame > totalFrames - 1 )			{				_frame = totalFrames - 1;			}			else			{				_frame = frame;			}			isPlaying = false;						width 	= animation[ _frame ].width;			height 	= animation[ _frame ].height;		}				/**		 * @private		 */		public override function update():void		{			if ( isPlaying )			{				if ( _frame < totalFrames - 2 )				{					_frame++;				}				else				{					_frame = 0;				}			}						bitmapData = animation[ _frame ];			super.update();		}	}}